
# アラーム実装に関するレビュー

## 1. はじめに

このドキュメントは、WeeklySignalアプリケーションのAndroidにおけるアラーム実装に関するレビュー結果をまとめたものです。
主に、アラームの正確性、堅牢性、効率性、そしてコード品質の観点から評価と改善提案を行います。

## 2. 全体評価

総じて、アラーム機能は非常によく実装されています。特に以下の点は高く評価できます。

- **モダンなAPIの活用**: `setExactAndAllowWhileIdle` を使用し、Dozeモードのような省電力機能が有効な状態でも、指定時刻に正確なアラームが発火するよう考慮されています。
- **堅牢な繰り返し処理**: `setRepeating`系のAPIに頼らず、`AlarmReceiver`内で次の週のアラームを手動で再スケジュールする方式を採用しています。これにより、OSのバージョンやメーカーの実装差異による影響を受けにくく、信頼性の高い繰り返し処理が実現できています。
- **永続化と再起動への対応**: `SharedPreferences`にアラーム情報を保存し、`BootReceiver`でデバイス再起動時にアラームを自動で再設定する仕組みは、アプリケーションの信頼性を大きく向上させています。
- **適切な権限管理**: Android 12 (API 31) で導入された `SCHEDULE_EXACT_ALARM` 権限について、パーミッションの確認と要求フローが正しく実装されています。
- **クリーンなアーキテクチャ**: `commonMain`に `SignalAlarmManager` インターフェースを定義し、`androidMain`に具体的な実装を配置することで、プラットフォーム間の責務が明確に分離されており、Kotlin Multiplatformの設計思想に沿っています。

## 3. 改善提案

現在の実装は非常に優れていますが、さらに堅牢性やユーザー体験を向上させるために、以下の点を検討することをお勧めします。

### 3.1. 通知チャネルの設計について

**現状:**
サウンドとバイブレーションの有無に応じて、動的に異なる通知チャネルを生成しています。

```kotlin
// AndroidAlarmManager.kt
private fun createNotificationChannel(sound: Boolean, vibration: Boolean): String {
    val channelId = "${CHANNEL_ID_BASE}_${if (sound) "s" else "n"}_${if (vibration) "v" else "n"}"
    // ...
}
```

**提案:**
単一の通知チャネル（例: `weekly_signal_alarms`）を使用することを推奨します。

**理由:**
Androidの通知チャネルは、ユーザーが「通知の種類」ごとに設定をカスタマイズできるように設計されています。チャネルを動的に生成すると、ユーザーはOSの設定画面からサウンドやバイブレーションのON/OFFを個別に制御できなくなります。単一のチャネルに統一することで、ユーザーは「WeeklySignalのアラーム」というカテゴリに対して、好みの通知スタイル（音、バイブレーション、ポップアップの有無など）を自由に設定できるようになり、ユーザー体験が向上します。

### 3.2. フルスクリーンインテントの利用について

**現状:**
`AlarmReceiver`で通知を生成する際に、`setFullScreenIntent` を使用しています。

```kotlin
// AlarmReceiver.kt
val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
    // ...
    .setFullScreenIntent(createFullScreenIntent(context, alarmInfo.alarmId), true)
```

**提案:**
この機能がアプリケーションのコア要件でない限り、通常の通知（`setContentIntent`）への変更を検討してください。

**理由:**
フルスクリーンインテントは、電話の着信画面のように、ユーザーの操作を強制的に中断させる非常に強力なUIです。Android 10以降では、この機能の使用に `USE_FULL_SCREEN_INTENT` 権限が必要になるなど、OSによる制限も厳しくなっています。単なるリマインダー目的の場合、ユーザーにとっては過剰な割り込みとなり、不快感を与える可能性があります。

### 3.3. アラーム音の停止処理

**現状:**
通知の"Dismiss"アクションでは、`NotificationManagerCompat.cancel()`を呼び出して通知を消去していますが、アラーム音を明示的に停止する処理は含まれていません。

**提案:**
`RingtoneManager.TYPE_ALARM`で取得したサウンドは、ユーザーが操作するまで鳴り続ける可能性があります。Dismissアクションが実行された際に、再生中のアラーム音を停止するロジックを追加することを検討してください。これには、`Ringtone`オブジェクトをサービスや`AlarmReceiver`内で管理し、必要に応じて `stop()` を呼び出す処理が必要になります。

### 3.4. データ永続化戦略

**現状:**
アラーム情報は`SharedPreferences`にJSON文字列として保存されています。

**提案:**
アプリケーションでは既にRoomデータベースが導入されているため、アラームの状態管理もRoomに統合することを検討してください。

**理由:**
`SharedPreferences`は手軽ですが、大量の構造化データを扱う場合、パフォーマンスや型安全性の面でデータベースに劣ります。例えば、`TimeSlotEntity`に `isAlarmScheduled` (Boolean) や `pendingIntentRequestCode` (Int) のようなカラムを追加することで、データの一貫性を保ちやすくなり、`SignalItem`の更新や削除とアラームの状態をトランザクションで安全に管理できます。

### 3.5. テストの拡充

**現状:**
アラーム関連のロジック（特に時刻計算）は、`calculateNextAlarmTime` や `scheduleNextWeekAlarm` など、複数の箇所に存在します。

**提案:**
これらのクリティカルなロジックに対して、ユニットテストを追加することを強く推奨します。特に、曜日や時刻が境界値になるケース（例: 週の終わり、深夜0時をまたぐ場合など）を網羅的にテストすることで、意図しない挙動を防ぎ、将来のリファクタリングを容易にします。

## 4. まとめ

WeeklySignalのアラーム機能は、信頼性が高く、現代的なAndroidアプリの要件を満たす優れた実装です。本レビューで提案した項目は、主にユーザー体験のさらなる向上と、将来のメンテナンス性を見据えたものです。これらの点を改善することで、アプリケーションの完成度をより一層高めることができるでしょう。
